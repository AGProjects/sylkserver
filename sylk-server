#!/usr/bin/env python

import os
import signal
import sys

from application import log
from application.configuration import ConfigFile
from application.process import process, ProcessError
from optparse import OptionParser

import sipsimple
import sylk


def main():
    name = 'sylk-server'
    fullname = 'SylkServer'
    runtime_directory = '/var/run/sylkserver'
    system_config_directory = '/etc/sylkserver'
    default_pid = os.path.join(runtime_directory, 'server.pid')
    default_config = sylk.configuration_filename if os.path.isfile(sylk.configuration_filename) else os.path.join(system_config_directory, sylk.configuration_filename)

    parser = OptionParser(version='%%prog %s' % sylk.__version__)
    parser.add_option('--no-fork', action='store_false', dest='fork', default=1,
                      help='run the process in the foreground (for debugging)')
    parser.add_option('--pid', dest='pid_file',
                      help='pid file ("%s")' % default_pid, metavar='File')
    parser.add_option('--config-file', dest='config_file', default=default_config,
                      help='path to configuration file to read ("%s")' % default_config,
                      metavar='File')
    parser.add_option('--enable-bonjour', action='store_true', dest='enable_bonjour', default=False,
                      help='enable Bonjour services')
    parser.add_option('--debug-memory', action='store_true', dest='debug_memory', default=False,
                      help='enable memory debugging (works only if --no-fork is specified)')
    (options, args) = parser.parse_args()

    path, configuration_filename = os.path.split(options.config_file)
    if path:
        system_config_directory = path

    process.system_config_directory = system_config_directory
    sylk.configuration_filename = process.config_file(options.config_file)
    pid_file = options.pid_file or default_pid

    # when run in foreground, do not require root access because of /var/run/sylkserver
    if not options.fork:
        process._runtime_directory = None
    else:
        try:
            process.runtime_directory = runtime_directory
            process.daemonize(pid_file)
        except ProcessError as e:
            log.fatal('Cannot start {name}: {exception!s}'.format(name=fullname, exception=e))
            sys.exit(1)
        log.start_syslog(name)

    from sylk.server import SylkServer

    log.info('Starting {name} {module.__version__}, using SIP SIMPLE SDK {sipsimple.__version__}'.format(name=fullname, module=sylk, sipsimple=sipsimple))

    config_file = ConfigFile(sylk.configuration_filename)
    if config_file.files:
        log.info('Reading configuration from {}'.format(', '.join(config_file.files)))
    else:
        log.info('Not reading any configuration files (using internal defaults)')

    if not options.fork and options.debug_memory:
        import atexit
        from application.debug.memory import memory_dump
        atexit.register(memory_dump)

    server = SylkServer()

    def stop_server(*args):
        if not server.stopping_event.is_set():
            log.info('Stopping {name}...'.format(name=fullname))
            server.stop()

    process.signals.add_handler(signal.SIGTERM, stop_server)
    process.signals.add_handler(signal.SIGINT, stop_server)

    def toggle_debugging(*args):
        from sylk.configuration import ServerConfig
        if log.level.current != log.level.DEBUG:
            log.level.current = log.level.DEBUG
            log.info('Switched logging level to DEBUG')
        else:
            log.info('Switched logging level to {}'.format(ServerConfig.log_level))
            log.level.current = ServerConfig.log_level

    process.signals.add_handler(signal.SIGUSR1, toggle_debugging)

    try:
        server.start(options)
    except Exception as e:
        log.fatal('Failed to run {name}: {exception!s}'.format(name=fullname, exception=e))
        log.exception()
        sys.exit(1)
    else:
        while not server.stopping_event.wait(9999):
            pass
        server.stop_event.wait(5)
        if server.stop_event.is_set():
            log.info('{name} stopped'.format(name=fullname))
        else:
            log.info('Forcefully exiting {name}...'.format(name=fullname))
            os._exit(1)

    sys.exit(int(server.failed))


if __name__ == "__main__":
    main()
