#!/usr/bin/env python

import os
import signal
import sys

from application import log
from application.process import process, ProcessError
from optparse import OptionParser

import sipsimple
import sylk


# noinspection PyUnusedLocal
def stop_server(signum, frame):
    sylk_server = SylkServer()
    sylk_server.stop()


# noinspection PyUnusedLocal
def toggle_debugging(signum, frame):
    if log.level.current != log.level.DEBUG:
        log.level.current = log.level.DEBUG
        log.info('Switched logging level to DEBUG')
    else:
        log.info('Switched logging level to {}'.format(ServerConfig.log_level))
        log.level.current = ServerConfig.log_level


if __name__ == '__main__':
    name = 'sylk-server'
    fullname = 'SylkServer'
    runtime_directory = '/var/run/sylkserver'
    system_config_directory = '/etc/sylkserver'
    default_pid = os.path.join(runtime_directory, 'server.pid')
    default_config = sylk.configuration_filename if os.path.isfile(sylk.configuration_filename) else os.path.join(system_config_directory, sylk.configuration_filename)

    parser = OptionParser(version='%%prog %s' % sylk.__version__)
    parser.add_option('--no-fork', action='store_false', dest='fork', default=1,
                      help='run the process in the foreground (for debugging)')
    parser.add_option('--pid', dest='pid_file',
                      help='pid file (%r)' % default_pid, metavar='File')
    parser.add_option('--config-file', dest='config_file', default=default_config,
                      help='path to configuration file to read (%r)' % default_config,
                      metavar='File')
    parser.add_option('--enable-bonjour', action='store_true', dest='enable_bonjour', default=False,
                      help='enable Bonjour services')
    parser.add_option('--debug-memory', action='store_true', dest='debug_memory', default=False,
                      help='enable memory debugging (only works with --no-fork)')

    options, args = parser.parse_args()

    path, configuration_filename = os.path.split(options.config_file)
    if path:
        system_config_directory = path

    process.system_config_directory = system_config_directory
    sylk.configuration_filename = process.config_file(options.config_file)
    pid_file = options.pid_file or default_pid

    # when run in foreground, do not require root access because of /var/run/sylkserver
    if not options.fork:
        process._runtime_directory = None
    else:
        try:
            process.runtime_directory = runtime_directory
            process.daemonize(pid_file)
        except ProcessError as e:
            log.fatal('Cannot start {name}: {exception!s}'.format(name=fullname, exception=e))
            sys.exit(1)
        log.start_syslog(name)

    from sylk.server import SylkServer, ServerConfig

    log.info('Starting {name} {module.__version__}, using SIP SIMPLE SDK {sipsimple.__version__}'.format(name=fullname, module=sylk, sipsimple=sipsimple))

    config_file = ServerConfig.__cfgtype__(ServerConfig.__cfgfile__)
    if config_file.files:
        log.info('Reading configuration from {}'.format(', '.join(config_file.files)))
    else:
        log.info('Not reading any configuration files (using internal defaults)')

    if not options.fork and options.debug_memory:
        import atexit
        from application.debug.memory import memory_dump
        atexit.register(memory_dump)

    process.signals.add_handler(signal.SIGTERM, stop_server)
    process.signals.add_handler(signal.SIGINT, stop_server)
    process.signals.add_handler(signal.SIGUSR1, toggle_debugging)

    server = SylkServer()
    try:
        server.run(options)
    except Exception as e:
        log.fatal('Failed to start {name}: {exception!s}'.format(name=fullname, exception=e))
        log.exception()
        sys.exit(1)

    # the run() method returns after the server is stopped

    if server.state == 'stopped':
        log.info('{name} stopped'.format(name=fullname))
        sys.exit(int(server.failed))
    else:
        log.info('Forcefully exiting {name}...'.format(name=fullname))
        # noinspection PyProtectedMember
        os._exit(1)
